/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { type Context, useContext, queryKeyFn } from "./context";
import { deepMerge } from "./utils";
import type * as Fetcher from "./fetcher";
import { fetch } from "./fetcher";
import type * as Schemas from "./schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type LogoutError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type LogoutVariables = Context["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  fetch<Schemas.Logout200ResponseBody, LogoutError, undefined, {}, {}, {}>({
    url: "/api/auth/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Logout200ResponseBody,
      LogoutError,
      LogoutVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.Logout200ResponseBody,
    LogoutError,
    LogoutVariables
  >({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCurrentUserError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type GetCurrentUserVariables = Context["fetcherOptions"];

export const fetchGetCurrentUser = (
  variables: GetCurrentUserVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.GetCurrentUser200ResponseBody,
    GetCurrentUserError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/auth/me", method: "get", ...variables, signal });

export function getCurrentUserQuery(variables: GetCurrentUserVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.GetCurrentUser200ResponseBody>;
};

export function getCurrentUserQuery(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.GetCurrentUser200ResponseBody>)
    | reactQuery.SkipToken;
};

export function getCurrentUserQuery(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/auth/me",
      operationId: "getCurrentUser",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCurrentUser(variables, signal),
  };
}

export const useSuspenseGetCurrentUser = <
  TData = Schemas.GetCurrentUser200ResponseBody,
>(
  variables: GetCurrentUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetCurrentUser200ResponseBody,
      GetCurrentUserError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.GetCurrentUser200ResponseBody,
    GetCurrentUserError,
    TData
  >({
    ...getCurrentUserQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCurrentUser = <
  TData = Schemas.GetCurrentUser200ResponseBody,
>(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetCurrentUser200ResponseBody,
      GetCurrentUserError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.GetCurrentUser200ResponseBody,
    GetCurrentUserError,
    TData
  >({
    ...getCurrentUserQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RequestMagicLinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.RequestMagicLink400ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type RequestMagicLinkVariables = {
  body: Schemas.RequestMagicLinkRequestBody;
} & Context["fetcherOptions"];

export const fetchRequestMagicLink = (
  variables: RequestMagicLinkVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.RequestMagicLink200ResponseBody,
    RequestMagicLinkError,
    Schemas.RequestMagicLinkRequestBody,
    {},
    {},
    {}
  >({
    url: "/api/auth/request-magic-link",
    method: "post",
    ...variables,
    signal,
  });

export const useRequestMagicLink = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RequestMagicLink200ResponseBody,
      RequestMagicLinkError,
      RequestMagicLinkVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.RequestMagicLink200ResponseBody,
    RequestMagicLinkError,
    RequestMagicLinkVariables
  >({
    mutationFn: (variables: RequestMagicLinkVariables) =>
      fetchRequestMagicLink(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type VerifyMagicLinkError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.VerifyMagicLink400ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type VerifyMagicLinkVariables = {
  body: Schemas.VerifyMagicLinkRequestBody;
} & Context["fetcherOptions"];

export const fetchVerifyMagicLink = (
  variables: VerifyMagicLinkVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.VerifyMagicLink200ResponseBody,
    VerifyMagicLinkError,
    Schemas.VerifyMagicLinkRequestBody,
    {},
    {},
    {}
  >({
    url: "/api/auth/verify-magic-link",
    method: "post",
    ...variables,
    signal,
  });

export const useVerifyMagicLink = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.VerifyMagicLink200ResponseBody,
      VerifyMagicLinkError,
      VerifyMagicLinkVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.VerifyMagicLink200ResponseBody,
    VerifyMagicLinkError,
    VerifyMagicLinkVariables
  >({
    mutationFn: (variables: VerifyMagicLinkVariables) =>
      fetchVerifyMagicLink(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ContactError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type ContactVariables = {
  body: Schemas.ContactRequestBody;
} & Context["fetcherOptions"];

export const fetchContact = (
  variables: ContactVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.Contact200ResponseBody,
    ContactError,
    Schemas.ContactRequestBody,
    {},
    {},
    {}
  >({ url: "/api/contact", method: "post", ...variables, signal });

export const useContact = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Contact200ResponseBody,
      ContactError,
      ContactVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.Contact200ResponseBody,
    ContactError,
    ContactVariables
  >({
    mutationFn: (variables: ContactVariables) =>
      fetchContact(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SubscribeNewsletterError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type SubscribeNewsletterVariables = {
  body: Schemas.SubscribeNewsletterRequestBody;
} & Context["fetcherOptions"];

export const fetchSubscribeNewsletter = (
  variables: SubscribeNewsletterVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SubscribeNewsletter200ResponseBody,
    SubscribeNewsletterError,
    Schemas.SubscribeNewsletterRequestBody,
    {},
    {},
    {}
  >({ url: "/api/newsletter", method: "post", ...variables, signal });

export const useSubscribeNewsletter = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SubscribeNewsletter200ResponseBody,
      SubscribeNewsletterError,
      SubscribeNewsletterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.SubscribeNewsletter200ResponseBody,
    SubscribeNewsletterError,
    SubscribeNewsletterVariables
  >({
    mutationFn: (variables: SubscribeNewsletterVariables) =>
      fetchSubscribeNewsletter(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCurrentSubscriptionError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.GetCurrentSubscription401ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type GetCurrentSubscriptionVariables = Context["fetcherOptions"];

export const fetchGetCurrentSubscription = (
  variables: GetCurrentSubscriptionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.GetCurrentSubscription200ResponseBody,
    GetCurrentSubscriptionError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/subscription", method: "get", ...variables, signal });

export function getCurrentSubscriptionQuery(
  variables: GetCurrentSubscriptionVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.GetCurrentSubscription200ResponseBody>;
};

export function getCurrentSubscriptionQuery(
  variables: GetCurrentSubscriptionVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.GetCurrentSubscription200ResponseBody>)
    | reactQuery.SkipToken;
};

export function getCurrentSubscriptionQuery(
  variables: GetCurrentSubscriptionVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/subscription",
      operationId: "getCurrentSubscription",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCurrentSubscription(variables, signal),
  };
}

export const useSuspenseGetCurrentSubscription = <
  TData = Schemas.GetCurrentSubscription200ResponseBody,
>(
  variables: GetCurrentSubscriptionVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetCurrentSubscription200ResponseBody,
      GetCurrentSubscriptionError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.GetCurrentSubscription200ResponseBody,
    GetCurrentSubscriptionError,
    TData
  >({
    ...getCurrentSubscriptionQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCurrentSubscription = <
  TData = Schemas.GetCurrentSubscription200ResponseBody,
>(
  variables: GetCurrentSubscriptionVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetCurrentSubscription200ResponseBody,
      GetCurrentSubscriptionError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.GetCurrentSubscription200ResponseBody,
    GetCurrentSubscriptionError,
    TData
  >({
    ...getCurrentSubscriptionQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateSubscriptionError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.CreateSubscription401ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type CreateSubscriptionVariables = {
  body: Schemas.CreateSubscriptionRequestBody;
} & Context["fetcherOptions"];

export const fetchCreateSubscription = (
  variables: CreateSubscriptionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.CreateSubscription201ResponseBody,
    CreateSubscriptionError,
    Schemas.CreateSubscriptionRequestBody,
    {},
    {},
    {}
  >({ url: "/api/subscription", method: "post", ...variables, signal });

export const useCreateSubscription = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateSubscription201ResponseBody,
      CreateSubscriptionError,
      CreateSubscriptionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.CreateSubscription201ResponseBody,
    CreateSubscriptionError,
    CreateSubscriptionVariables
  >({
    mutationFn: (variables: CreateSubscriptionVariables) =>
      fetchCreateSubscription(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UpdateSubscriptionError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UpdateSubscription401ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type UpdateSubscriptionVariables = {
  body: Schemas.UpdateSubscriptionRequestBody;
} & Context["fetcherOptions"];

export const fetchUpdateSubscription = (
  variables: UpdateSubscriptionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.UpdateSubscription200ResponseBody,
    UpdateSubscriptionError,
    Schemas.UpdateSubscriptionRequestBody,
    {},
    {},
    {}
  >({ url: "/api/subscription", method: "patch", ...variables, signal });

export const useUpdateSubscription = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdateSubscription200ResponseBody,
      UpdateSubscriptionError,
      UpdateSubscriptionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.UpdateSubscription200ResponseBody,
    UpdateSubscriptionError,
    UpdateSubscriptionVariables
  >({
    mutationFn: (variables: UpdateSubscriptionVariables) =>
      fetchUpdateSubscription(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ReplaceSubscriptionError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type ReplaceSubscriptionVariables = {
  body: Schemas.ReplaceSubscriptionRequestBody;
} & Context["fetcherOptions"];

export const fetchReplaceSubscription = (
  variables: ReplaceSubscriptionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ReplaceSubscription200ResponseBody,
    ReplaceSubscriptionError,
    Schemas.ReplaceSubscriptionRequestBody,
    {},
    {},
    {}
  >({ url: "/api/subscription", method: "put", ...variables, signal });

export const useReplaceSubscription = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ReplaceSubscription200ResponseBody,
      ReplaceSubscriptionError,
      ReplaceSubscriptionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.ReplaceSubscription200ResponseBody,
    ReplaceSubscriptionError,
    ReplaceSubscriptionVariables
  >({
    mutationFn: (variables: ReplaceSubscriptionVariables) =>
      fetchReplaceSubscription(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CancelSubscriptionError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.CancelSubscription401ResponseBody;
    }
  | {
      status: 500;
      payload: Schemas.ErrorMessage;
    }
>;

export type CancelSubscriptionVariables = {
  body: Schemas.CancelSubscriptionRequestBody;
} & Context["fetcherOptions"];

export const fetchCancelSubscription = (
  variables: CancelSubscriptionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.CancelSubscription200ResponseBody,
    CancelSubscriptionError,
    Schemas.CancelSubscriptionRequestBody,
    {},
    {},
    {}
  >({ url: "/api/subscription", method: "delete", ...variables, signal });

export const useCancelSubscription = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CancelSubscription200ResponseBody,
      CancelSubscriptionError,
      CancelSubscriptionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.CancelSubscription200ResponseBody,
    CancelSubscriptionError,
    CancelSubscriptionVariables
  >({
    mutationFn: (variables: CancelSubscriptionVariables) =>
      fetchCancelSubscription(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ListPlansError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorMessage;
}>;

export type ListPlansVariables = Context["fetcherOptions"];

export const fetchListPlans = (
  variables: ListPlansVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ListPlans200ResponseBody,
    ListPlansError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/subscription/plans", method: "get", ...variables, signal });

export function listPlansQuery(variables: ListPlansVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.ListPlans200ResponseBody>;
};

export function listPlansQuery(
  variables: ListPlansVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ListPlans200ResponseBody>)
    | reactQuery.SkipToken;
};

export function listPlansQuery(
  variables: ListPlansVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/subscription/plans",
      operationId: "listPlans",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListPlans(variables, signal),
  };
}

export const useSuspenseListPlans = <TData = Schemas.ListPlans200ResponseBody,>(
  variables: ListPlansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListPlans200ResponseBody,
      ListPlansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ListPlans200ResponseBody,
    ListPlansError,
    TData
  >({
    ...listPlansQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useListPlans = <TData = Schemas.ListPlans200ResponseBody,>(
  variables: ListPlansVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListPlans200ResponseBody,
      ListPlansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.ListPlans200ResponseBody,
    ListPlansError,
    TData
  >({
    ...listPlansQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/auth/me";
      operationId: "getCurrentUser";
      variables: GetCurrentUserVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/subscription";
      operationId: "getCurrentSubscription";
      variables: GetCurrentSubscriptionVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/subscription/plans";
      operationId: "listPlans";
      variables: ListPlansVariables | reactQuery.SkipToken;
    };
